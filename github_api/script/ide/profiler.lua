--[[
Author: Li,Xizhi
Date: 2009-12-29
Desc: Profiler for finding the performance hot spot.
---++ Using NPL Profiler
Just include this file in your script and it will define a profiler module with two functions:

profiler.start([filename]); -- Starts the profiler using the optional filename as the log file. 
profiler.stop(); -- Stops the profiler. 

You can restart the profiler after a stop with another call to start.

All you need now is to run your program and get the output generated by the profiler. The default log file is 
written to the working directory of the program, in a file like lprof_randomid.out where randomid is a random number.
 The log format uses a line for every function call in your program which may result in huge files, so be careful 
 with disk space if your program runs for a long time, or use localized profiling wrapping the target section with 
 a start()/stop() call sequence.

We analyze the output of the profiler and generates a table with the functions used by your program and their running times, 
ordered according to how much of the total execution time of your program the function used. This script needs to be interpreted by Lua.

commonlib.npl_profiler.AnalyzeSummary(filename)
You can also pass the -v option to summary.lua, just before the name of the log file, to generate a more comprehensive summary, 
containing the number of times each function was called, their average running times, and the percentage of the total running time 
of your script each function took.

-----------------------------------------------
NPL.load("(gl)script/ide/profiler.lua");

-- method1: 
profiler.start("profiler.txt");
	
	log("run some code 11111111111")
	log("run some code 22222222222")
	
profiler.stop();

-- method2: 
-- generate summary to "profiler.txt.summary"
commonlib.npl_profiler.AnalyzeSummary("-v", "profiler.txt")

-- alternatively, one can simply call following twice to generate a full report in between
commonlib.npl_profiler.ToggleProfiling()
-- or one can simply activate to profile a given thread. 
NPL.activate("(gl)script/ide/profiler.lua");

-- method3:
local npl_profiler = commonlib.gettable("commonlib.npl_profiler");
npl_profiler.perf_show();

npl_profiler.perf_begin("test")
-- code here will be perfed
npl_profiler.perf_end("test")
-----------------------------------------------
]]
profiler = luaopen_profiler();
commonlib.profiler = profiler;

local npl_profiler = commonlib.gettable("commonlib.npl_profiler");
local getAccurateTime = ParaGlobal.getAccurateTime;
local table_insert = table.insert;

local LOG = LOG;
local parent_folder = "__profiler/"
if(not ParaIO.CreateDirectory(parent_folder)) then
	LOG.error("profiler can not create directory in %s", parent_folder);
end

------------------------------------------------------------
-- The following few functions are refactored from luaprofiler
-- LuaProfiler
-- Copyright Kepler Project 2005-2007 (http://www.keplerproject.org/luaprofiler)       
------------------------------------------------------------

local last_file_name;
local last_start_time;
-- a helper function to toggle profiling on/off
-- and generate summary once turned off. new report file will be written to ./profiler_[date]_[time]
function npl_profiler.ToggleProfiling()
	if(not last_file_name) then
		last_file_name = string.format("%sprofiler_%s_%s.txt", parent_folder, ParaGlobal.GetDateFormat("yyyy-M-d"), ParaGlobal.GetTimeFormat("H-mm-ss"));
		last_start_time = ParaGlobal.timeGetTime();
		LOG.std(nil, "system", "profiler", "npl_profiler.ToggleProfiling started")
		profiler.start(last_file_name);
	else
		LOG.std(nil, "system", "profiler", "npl_profiler.ToggleProfiling stopped")
		profiler.stop();
		local elapsed_time = ParaGlobal.timeGetTime() - last_start_time;
		npl_profiler.AnalyzeSummary("-v", last_file_name)
		if(ParaUI and ParaUI.CreateUIObject and not ParaEngine.GetAttributeObject():GetField("IsServerMode", false)) then
			_guihelper.MessageBox(string.format("Profiling %dms result is generated to %s\n", elapsed_time, last_file_name))
		else
			LOG.std(nil, "system", "profiler", "Profiling %dms result is generated to %s", elapsed_time, last_file_name)
		end
		last_file_name = nil;
	end
end

-- Function that reads one profile file
function npl_profiler.ReadProfile(file)
	local profile

	-- Check if argument is a file handle or a filename
	if io.type(file) == "file" then
		profile = file

	else
		-- Open profile
		profile = io.open(file)
	end

	-- Table for storing each profile's set of lines
	line_buffer = {}

	-- Get all profile lines
	local i = 1
	for line in profile:lines() do
		line_buffer[i] = line
		i = i + 1
    end

	-- Close file
	profile:close()
	return line_buffer
end

-- Function that creates the summary info
function npl_profiler.CreateSummary(lines, summary)

	local global_time = 0
	local tonumber = tonumber;
	local string_match = string.match;
	local nLineCount = #lines;
	-- Note: ignore first line
	for i = 2, nLineCount do
		word = string_match(lines[i], "[^\t]+\t[^\t]+\t([^\t]+)")
		local_time, total_time = string_match(lines[i], "[^\t]+\t[^\t]+\t[^\t]+\t[^\t]+\t[^\t]+\t([^\t]+)\t([^\t]+)")
		
		local_time = tonumber(local_time)
		total_time = tonumber(total_time)
		
        if not (local_time and total_time) then return global_time end
        
        if summary[word] == nil then
			summary[word] = {};
			summary[word]["info"] = {}
			summary[word]["info"]["calls"] = 1
			summary[word]["info"]["total"] = local_time
			summary[word]["info"]["func"] = word

		else
			summary[word]["info"]["calls"] = summary[word]["info"]["calls"] + 1
			summary[word]["info"]["total"] = summary[word]["info"]["total"] + local_time;
		end

		global_time = global_time + local_time;
	end

	return global_time
end

-- e.g. commonlib.npl_profiler.AnalyzeSummary("-v", "profiler_result.out")
-- @param arg1: "-v" or filename
-- @param arg2: filename if arg1 is "-v"
function npl_profiler.AnalyzeSummary(...)
	local arg = {...};
	
	-- Global time
	global_t = 0

	-- Summary table
	profile_info = {}

	-- Check file type
	local verbose = false
	local filename
	if arg[1] == "-v" or arg[1] == "-V" then
	  verbose = true
	  filename = arg[2]
	else
	  filename = arg[1]
	end
	if filename then
	  file = io.open(filename)
	else
	  print("Usage")
	  print("-----")
	  print("lua summary.lua [-v] <profile_log>")
	  return
	end
	if not file then
	  print("File " .. filename .. " does not exist!")
	  return
	end
	firstline = file:read(11)

	-- File is single profile
	if firstline == "stack_level" then

		-- Single profile
		local lines = npl_profiler.ReadProfile(file)
		global_t = npl_profiler.CreateSummary(lines, profile_info)

	else

		-- File is list of profiles
		-- Reset position in file
		file:seek("set")

		-- Loop through profiles and create summary table
		for line in file:lines() do

			local profile_lines

			-- Read current profile
			profile_lines = npl_profiler.ReadProfile(line)

			-- Build a table with profile info
			global_t = global_t + npl_profiler.CreateSummary(profile_lines, profile_info)
		end

		file:close()
	end

	local out_file = ParaIO.open(filename..".summary", "w");
	
	-- Sort table by total time
	sorted = {}
	for k, v in pairs(profile_info) do table.insert(sorted, v) end
	table.sort(sorted, function (a, b) return tonumber(a["info"]["total"]) > tonumber(b["info"]["total"]) end)

	-- Output summary
	if verbose then
	  out_file:writeline("Node name\tCalls\tAverage per call\tTotal time\t%Time")
	else
	  out_file:writeline("Node name\tTotal time")
	end
	for k, v in pairs(sorted) do
		if v["info"]["func"] ~= "(null)" then
			local average = v["info"]["total"] / v["info"]["calls"]
			local percent = 100 * v["info"]["total"] / global_t
			if verbose then
			  out_file:writeline(v["info"]["func"] .. "\t" .. v["info"]["calls"] .. "\t" .. average .. "\t" .. v["info"]["total"] .. "\t" .. percent)
			else
			  out_file:writeline(v["info"]["func"] .. "\t" .. v["info"]["total"])
			end
		end
	end
	out_file:close();
end

local function activate()
	npl_profiler.ToggleProfiling();
end
NPL.this(activate);