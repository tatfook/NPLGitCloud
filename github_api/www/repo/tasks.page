<?npl
include_once("../user/tasks.page");
include_once("../tasks.page");

NPL.load("(gl)script/ide/System/Database/TableDatabase.lua");
local TableDatabase = commonlib.gettable("System.Database.TableDatabase");
local db = TableDatabase:new():connect("db/", function() end);

NPL.load("(gl)script/ide/Encoding.lua");
NPL.load("(gl)script/ide/Encoding/sha1.lua");
local Encoding = commonlib.gettable("commonlib.Encoding");

local function get_size_by_repo(repo)
    local size = 0;
    db.Dir:find({ repo = repo, type = "file" }, function(err, records)
        for i = 1, #records do
            size = size + records[i]["size"];
        end
    end);
    return size;
end

local function get_repo_from_db(record)
    local fullname = record["owner"] .. "/" .. record["name"];
    local result = {
        id = record["_id"],
        owner = get_user_by_username(record["owner"]),
        name = record["name"],
        full_name = fullname,
        description = record["description"],
        private = record["private"],
        fork = true,
        url = api_server_addr .. "/repos/" .. fullname,
        contents_url = api_server_addr .. "/repos/" .. fullname .. "/contents/{+path}",
        trees_url = api_server_addr .. "/repos/" .. fullname .. "/git/trees{/sha}",
        homepage = record["homepage"],
        language = nil,
        fork_count = 0,
        stargazers_count = 0,
        size = get_size_by_repo(fullname),
        default_branch = "master",
        open_issue_count = 0,
        has_issues = record["has_issues"],
        has_wiki = record["has_wiki"],
        has_pages = record["has_pages"],
        has_downloads = record["has_downloads"],
        pushed_at = record["pushed_at"],
        created_at = record["created_at"],
        updated_at = record["updated_at"],
        permissions = {
            admin = true,
            push = true,
            pull = true
        }
    };
    return result;
end

local function check_repo_exist(owner, reponame)
    local count;
    db.Repo:count({ owner = owner, name = reponame }, function(err, result) count = result; end);
    return count == 1;
end

local function get_dir_by_path(path)
    return path:gsub("/[^/]+$", "");
end

local function get_name_by_path(path)
    return path:match("[^/]+$");
end

local function check_path_exist(repo, path)
    if (path == ".") then
        return "dir";
    end
    local dir, name = get_dir_by_path(path), get_name_by_path(path);
    local result;
    db.Dir:findOne({ repo = repo, dir = dir, name = name }, function(err, record)
        if (record) then
            result = record["type"];
        end
    end);
    return result;
end

function check_file_exist(repo, path)
    local dir, name = get_dir_by_path(path), get_name_by_path(path);
    local result;
    db.Dir:count({ repo = repo, dir = dir, name = name, type = "file" }, function(err, record) result = record; end);
    return result == 1;
end

function check_sha_by_file(repo, path, sha)
    local dir, name = get_dir_by_path(path), get_name_by_path(path);
    local result;
    db.Dir:count({ repo = repo, dir = dir, name = name, type = "file", sha = sha }, function(err, record) result = record; end);
    return result == 1;
end

local function get_file_from_db(record)
    local path = record["dir"] .. "/" .. record["name"];
    local url = api_server_addr .. "/repos/" .. record["repo"] .. "/contents/" .. path;
    local result = {
        type = "file",
        encoding = "base64",
        size = record["size"],
        name = record["name"],
        path = path,
        content = record["content"],
        sha = record["sha"],
        url = url,
        _links = {
            self = url
        }
    };
    return result;
end

local function get_dir_item_from_db(record)
    local path = record["dir"] .. "/" .. record["name"];
    local url = api_server_addr .. "/repos/" .. record["repo"] .. "/contents/" .. path;
    local result = {
        type = "dir",
        size = 0,
        name = record["name"],
        path = path,
        sha = record["sha"],
        url = url,
        _links = {
            self = url
        }
    };
    return result;
end

local function get_items_by_dir(repo, dir)
    local results = {};
    db.Dir:findOne({ repo = repo, dir = dir }, function(err, record)
        table.insert(results, get_dir_item_from_db(record));
    end
    return results;
end

local function process_path(path)
    local result = path;
    if (not result or result == "" or result == "/") then
        result = ".";
    else
        result = "./" .. result;
    end
    result = result:gsub("/$", ""); 
    return result;
end

local function get_sha_by_file(content, size)
    local buffer = "blob " .. size .. "\0" .. content;
    local sha = Encoding.sha1(buffer);
    return sha;
end

local function get_sha_by_dir(repo, dir, name)
    local items = get_items_by_dir(repo, dir .. "/" .. name);
    local buffers = {};
    for i = 1, #items do
        if (items[i]["type"] == "file") then
            table.insert(buffers, "100644 " .. items[i]["name"] .. "\0" .. items[i]["sha"]);
        else
            table.insert(buffers, "040000 " .. items[i]["name"] .. "\0" .. items[i]["sha"]);
        end
    end
    local size = 0;
    for i = 1, #buffers do
        size = size + buffers[i]:len();
    end
    local buffer = "tree " .. tostring(size) .. "\0";
    for i = 1, #buffers do
        buffer = buffer .. buffers[i];
    end
    local sha = Encoding.sha1(buffer);
    return sha;
end

local function split_path(path)
    local dirs = {};
    for token in string.gmatch(path, "[^/]+") do
        table.insert(dirs, token);
    end
    return dirs;
end

local function insert_dir_if_not_exist(repo, dir, name)
    db.Dir:insertOne({ repo = repo, dir = dir, name = name }, {
        repo = repo,
        dir = dir,
        name = name,
        sha = get_sha_by_dir(repo, dir, name)
    }, function(err, data) end);
end

local function add_dirs_by_path(repo, path)
    local dirs = split_path(path);
    local paths = { [0] = ".." };
    for i = 1, #dirs do
        paths[i] = paths[i - 1] .. "/" .. dirs[i];
    end
    for i = #paths - 1, 1, -1 do
        insert_dir_if_not_exist(repo, paths[i - 1], dir[i]);
    end
end

function get_repos_by_user(user)
    local repos;
    db.Repo:find({ owner = user }, function(err, records)
        for i = 1, #records do
            table.insert(repos, get_repo_from_db(records[i]));
        end
    end);
    return repos;
end

function create_repo_by_options(options)
    if (check_repo_exist(options["owner"], options["name"])) then
        return nil;
    end
    local record;
    db.Repo:insertOne(nil, {
        owner = options["owner"],
        name = options["name"],
        description = options["description"],
        homepage = options["homepage"],
        private = options["private"],
        has_issues = options["has_issues"],
        has_wiki = options["has_wiki"],
        has_downloads = options["has_downloads"]
    }, function(err, data)
        record = data;
    end);
    local fullname = options["owner"] .. "/" .. options["name"];
    if (options["auto_init"]) then
        create_file(fullname, "README.md", "");
    end
    local repo = get_repo_from_db(record);
    return repo;
end

function delete_repo_by_reponame(owner, reponame)
    if (not check_repo_exist(owner, reponame)) then
        return false;
    end
    db.Repo:deleteOne({ owner = owner, name = reponame }, function(err, count) end);
    db.Dir:delete({ repo = owner .. "/" .. reponame }, function(err, count) end);
    return true;
end

function get_contents_by_repo_path(repo, path)
    path = process_path(path);
    local abs_path = repo .. "/" .. path;
    local type = check_path_exist(repo, path);
    if (not type) then
        return nil;
    end
    if (type == "file") then
        local dir, filename = get_dir_by_path(path), get_name_by_path(path);
        return get_file_by_repo_path(repo, dir, filename);
    else
        return get_items_by_dir(repo, path);
    end
end

function delete_file_by_options(options)
    local repo, path = options["repo"], process_path(options["path"]);
    if (not check_file_exist(repo, path)) then
        return false;
    end
    local dir, name = get_dir_by_path(path), get_name_by_path(path);
    db.Dir:deleteOne({ repo = repo, dir = dir, name = name }, function(err, count) end);
    return true;
end

function update_file_by_content(repo, path, content)
    path = process_path(path);
    local dir, name = get_dir_by_path(path), get_name_by_path(path);
    local decoded_content = Encoding.unbase64(content);
    local size = decoded_content:len();
    db.Dir:updateOne({ repo = repo, dir = dir, name = name }, { content = content, size = size, sha = get_sha_by_file(decoded_content, size) }, function(err, data) end);
    add_dirs_by_path(repo, path);
    local result = {
        content = get_file_by_repo_path(repo, dir, name);
    };
    return result;
end

function get_trees_by_repo(repo)
    local result = {};
    db.Dir:find({ repo = repo }, function(err, records)
        for i = 1, #records do
            local path = records[i]["dir"] .. "/" .. records[i]["name"];
            path = path:gsub("^%./", "");
            local mode, type;
            if (records[i]["type"] == "file") then
                table.insert(result, {
                    path = path,
                    mode = "100644",
                    type = "blob",
                    sha = records[i]["sha"],
                    size = records[i]["size"]
                });
            else
                table.insert(result, {
                    path = path,
                    mode = "040000",
                    type = "tree",
                    sha = records[i]["sha"],
                });
            end;
        end
    end);
    local returned_value = {
        tree = result,
        truncated = false
    };
    return returned_value;
end
?>
